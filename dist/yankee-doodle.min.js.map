{"mappings":"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","sources":["./src/parser.js","./src/yank.js","./src/filters.js","./src/serialiser.js","./src/validator.js"],"sourcesContent":["class Parser {\n  constructor (schemas) {\n    this.schemas = schemas\n    this.tokens = this\n      .strip()\n      .split(this.reg.keys)\n      .map(i => this.tokenise(i))\n  }\n\n  nodeify () {\n    const [token, shift] = this.tokens.shift()\n    const [key, ...raws] = token.split(Parser.tokens.DIV)\n    const node = {\n      children: [],\n      filters: this.filterfy(raws),\n      options: {\n        ...Parser.options\n      },\n      key: {\n        value: key,\n        path: key.split(Parser.tokens.SEG),\n        name: key\n          .split(Parser.tokens.SEG)\n          .pop()\n      }\n    }\n\n    return {\n      shift,\n      node\n    }\n  }\n\n  filterfy (raws) {\n    return raws.map(r => {\n      const [key, params] = r.split(/(?=\\([\\w$_,]*\\)|$)/g)\n      const [name, flag] = key.split(this.reg.flags)\n      const args = params\n        ?.replace(/\\(([\\w$_,]*)\\)/g, '$1')\n        .split(',')\n        .filter(Boolean)\n\n      return {\n        name,\n        args: args ?? [],\n        flag: {\n          value: flag ?? null,\n          on: (f, cb) => flag === f && cb()\n        }\n      }\n    })\n  }\n\n  tokenise (key) {\n    const [prop, ...scopes] = key.split(this.reg.scopes)\n    const length = this.measure(scopes)\n\n    return prop === Parser.tokens.CLOSE\n      ? [null, length - 1]\n      : [prop, length]\n  }\n\n  next (children) {\n    const { node, shift } = this.nodeify(children)\n    const depth = this.depth\n\n    this.depth += shift\n\n    while (shift > 0 && this.depth > depth) {\n      this.next(node.children)\n    }\n\n    if (node.key) children.push(node)\n  }\n\n  measure (scopes) {\n    return +scopes.includes(Parser.tokens.OPEN) || -scopes.length || 0\n  }\n\n  strip () {\n    const isNewLine = match => match === '\\n'\n    const isClose = (val, offset) => val[offset + 1] === Parser.tokens.CLOSE\n\n    return this.schema\n      .trim()\n      .replace(/\\s+/g, (m, v, o) => isNewLine(m) && !isClose(v, o) ? ',' : '')\n  }\n\n  parse () {\n    while (this.tokens.length) {\n      this.next(this.tree)\n    }\n\n    return this.tree\n  }\n\n  reg = {\n    get keys () {\n      return new RegExp(`,(?![^\\(]*[$\\)])|(?<=${Parser.tokens.OPEN})`)\n    },\n    get scopes () {\n      const { CLOSE, OPEN } = Parser.tokens\n\n      return new RegExp(`(?=[${CLOSE}]+)|(?=${OPEN})`)\n    },\n    get flags () {\n      const joined = Object\n        .values(Parser.tokens.FLAGS)\n        .map(i => `\\\\${i}`)\n        .join('|')\n\n      return new RegExp(`(?=${joined})`)\n    }\n  }\n\n  depth = 0\n\n  tree = []\n\n  get schema () {\n    return this.schemas.join(',')\n  }\n\n  static options = {\n    nullable: false,\n    extract: false,\n    exec: null\n  }\n\n  static tokens = {\n    OPEN: ':{',\n    CLOSE: '}',\n    DIV: '|',\n    SEG: '.',\n    FLAGS: {\n      MACRO: '!'\n    }\n  }\n}\n\nmodule.exports = {\n  Parser,\n  tokens: Parser.tokens,\n  flags: Parser.tokens.FLAGS\n}\n","const { Parser } = require('./parser')\nconst { Serialiser } = require('./serialiser')\nconst { validate } = require('./validator')\n\nmodule.exports = function yank (data, ...args) {\n  const schemas = validate(args.flat())\n  const parser = new Parser(schemas)\n  const serialiser = new Serialiser(data, parser.parse())\n\n  return serialiser.serialise()\n}\n","const { flags } = require('./parser')\n\nmodule.exports = {\n  as ({ node, args: [name] }) {\n    node.key.name = name\n  },\n  nullable ({ node, flag }) {\n    node.options.nullable = true\n\n    flag.on(flags.MACRO, () => {\n      for (const { options } of node.children) {\n        options.nullable = true\n      }\n    })\n  },\n  extract ({ node }) {\n    node.options.extract = true\n  },\n  exec ({ node, data, args: [name, ...args] }) {\n    const fn = data[name] ?? (() => null)\n\n    node.options.exec = v => fn(v, ...args)\n  }\n}\n","const filters = require('./filters')\nconst { errors } = require('./validator')\n\nconst { assign } = Object\n\nclass Serialiser {\n  constructor (data, ast) {\n    this.data = data\n    this.ast = ast\n  }\n\n  yank (node, data, parent) {\n    this.filter({\n      ast: this.ast,\n      node,\n      data,\n      parent\n    })\n\n    const value = this.get(data, node.key.path, node.options)\n    const set = this.set.bind(this, node, parent)\n\n    if (node.children.length) {\n      if (value || node.options.nullable) {\n        const children = this.dig(node, value)\n\n        if (node.options.extract) {\n          assign(parent, children)\n        } else {\n          set(children)\n        }\n      }\n    } else {\n      set(value)\n    }\n  }\n\n  dig (node, data) {\n    const result = {}\n    const nullable = node.children.every(n => !n.options.nullable)\n\n    if (!data && nullable) return null\n\n    for (const child of node.children) {\n      this.yank(child, data, result)\n    }\n\n    return result\n  }\n\n  filter (params) {\n    for (const { name, flag, args } of params.node.filters) {\n      const filter = filters[name]\n      const merged = assign(params, {\n        flag,\n        args\n      })\n\n      if (!filter) throw errors.filterNotFound(name)\n\n      filter(merged)\n    }\n  }\n\n  get (data, path, options) {\n    const value = path.reduce((acc, curr) => acc?.[curr], data)\n    const result = options.exec\n      ? options.exec(value)\n      : value\n\n    return options.nullable\n      ? result ?? null\n      : result\n  }\n\n  set (node, parent, value) {\n    parent[node.key.name] = value\n  }\n\n  serialise () {\n    for (const node of this.ast) {\n      this.yank(node, this.data, this.result)\n    }\n\n    return this.result\n  }\n\n  result = {}\n}\n\nmodule.exports = {\n  Serialiser\n}\n","const errors = {\n  invalidType: () => new Error('All schemas must be strings'),\n  filterNotFound: s => new Error(`Filter \"${s}\" could not be found`)\n}\n\nfunction validate (schemas) {\n  const typeIndex = schemas.findIndex(a => typeof a !== 'string')\n\n  if (typeIndex >= 0) throw errors.invalidType(schemas[typeIndex])\n\n  return schemas\n}\n\nmodule.exports = {\n  validate,\n  errors\n}\n"],"names":["$38bdd7c09594f76909d45ba83e72bfdc$var$Parser","Parser","schemas","RegExp","tokens","OPEN","CLOSE","joined","Object","values","FLAGS","map","i","join","this","strip","split","reg","keys","_this","tokenise","shift","token","DIV","key","raws","node","children","filters","filterfy","options","value","path","SEG","name","pop","r","_r$split2","$38bdd7c09594f76909d45ba83e72bfdc$var$_slicedToArray","params","flags","_this2","flag","args","replace","filter","Boolean","on","f","cb","scopes","prop","length","measure","nodeify","depth","next","push","includes","schema","trim","m","v","o","tree","nullable","extract","exec","MACRO","$106648ca3c52509c4c534b1a4d0ff701$var$Parser","$3572e7c27cd6a6a78c783cccef92024d$var$flags","$b5f9655fa81be7e50fa0cd2f53970017$var$filters","as","data","fn","$b86f0c91c494f502406841ca27322206$var$errors","invalidType","Error","filterNotFound","s","$b5f9655fa81be7e50fa0cd2f53970017$var$errors","validate","typeIndex","findIndex","a","errors","$b5f9655fa81be7e50fa0cd2f53970017$var$assign","assign","$106648ca3c52509c4c534b1a4d0ff701$var$Serialiser","Serialiser","$b5f9655fa81be7e50fa0cd2f53970017$var$Serialiser","ast","parent","get","set","bind","dig","result","every","n","child","yank","merged","reduce","acc","curr","$106648ca3c52509c4c534b1a4d0ff701$var$validate","flat","parser","serialiser","parse","serialise"],"version":3,"file":"yankee-doodle.min.js.map"}